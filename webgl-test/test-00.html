<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
}

body {
    display: flex;
    align-items: center;
    justify-content: center;
}

canvas {
    display: block;
}
</style>

<title>test-00</title>
</head>
<body>
<canvas width=400 height=400></canvas>
<script id="vs" type="x-shader/x-vertex">#version 300 es
precision highp float;

const vec2 pos[3] = vec2[](
    vec2(-1.0, -1.0),
    vec2( 3.0, -1.0),
    vec2(-1.0,  3.0)
);

void main() {
    gl_Position = vec4(pos[gl_VertexID], 0.0, 1.0);
}
</script>


<script id="fs" type="x-shader/x-fragment">#version 300 es
precision mediump float;

#define PI 3.141592653589793

struct BALL
{
    float r;
    vec2 xy;
    vec2 v;
    vec4 rgba;
};

struct PAD
{
    float width;
    float height;
    vec4 rgba;
};

uniform vec2 u_resolution;
uniform float u_time;
uniform vec2 u_mouse_pos;

uniform BALL u_ball;
uniform PAD u_pad;

out vec4 frag_color;

vec4 draw_background()
{
    vec2 p = gl_FragCoord.xy;

    // grid size
    vec2 cellSize = vec2(80.0, 80.0);

    // animate grid movement
    vec2 uv = (p + vec2(u_mouse_pos.x * 80.0, u_time * 40.0)) / cellSize;

    vec2 f = fract(uv);

    // distance to grid vertex (corner)
    float d = length(f);

    // dot radius
    float r = 0.15;

    float dot = 1.0 - step(r, d);

    return vec4(vec3(dot / 8.0), 1.0);
}

vec4 draw_ball(in vec2 frag_xy, in vec4 prev_clr)
{
    float d = length(frag_xy - u_ball.xy);

    float mask = 1.0 - step(u_ball.r, d);

    float brightness = (frag_xy.x - u_ball.xy.x) / u_ball.r;
    brightness = brightness * 0.5 + 0.5;

    return mix(prev_clr, u_ball.rgba * brightness, mask);
}

vec4 draw_pad(vec2 frag_pos, vec4 color)
{
    vec2 pad_center = vec2(u_mouse_pos.x, -1.0 + u_pad.height * 0.5);

    vec2 d = abs(frag_pos - pad_center);
    vec2 h = vec2(u_pad.width, u_pad.height) * 0.5;

    float outer = step(d.x, h.x) * step(d.y, h.y);

    float border_w = 0.01;
    vec2 hi = h - border_w;

    float inner = step(d.x, hi.x) * step(d.y, hi.y);

    float body = inner;
    float border = outer - inner;

    float gx = (frag_pos.x - pad_center.x) / h.x;
    float light = gx * 0.5 + 0.5;

    vec4 body_col   = u_pad.rgba * light;
    vec4 border_col = u_pad.rgba * 0.25;

    vec4 pad_col = body_col * body + border_col * border;

    return mix(color, pad_col, outer);
}

vec4 draw_border(in vec4 prev_clr, vec4 border_clr)
{
    vec2 p = gl_FragCoord.xy;
    return (p.x < 3.0
            || p.y < 3.0
            || p.x > u_resolution.x - 3.0
            || p.y > u_resolution.y - 3.0) ? border_clr : prev_clr;
}

void main()
{
    vec2 frag_xy = 2.0 * gl_FragCoord.xy / u_resolution - 1.0;
    vec4 curr_clr = draw_background();
    curr_clr = draw_ball(frag_xy, curr_clr);
    curr_clr = draw_pad(frag_xy, curr_clr);
    curr_clr = draw_border(curr_clr, vec4(0.0, 1.0, 0.0, 1.0));
    frag_color = curr_clr;
}
</script>
</body>
<script>
const canvas = document.querySelector('canvas');
var normMouseX = 0.0;
var normMouseY = 0.0;

canvas.style.touchAction = 'none';
canvas.addEventListener("pointerdown", updatePointer);
canvas.addEventListener("pointermove", updatePointer);
canvas.addEventListener('pointerup', updatePointer);
canvas.addEventListener('pointercancel', updatePointer);

function updatePointer(e) {
    const rect = canvas.getBoundingClientRect();
    normMouseX = (e.clientX - rect.left) / rect.width * 2.0 - 1.0;
    normMouseY = 1.0 - (e.clientY - rect.top) / rect.height * 2.0;
}

const gl = canvas.getContext('webgl2');
const program = gl.createProgram();

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, vs.innerText);
gl.compileShader(vertexShader);
gl.attachShader(program, vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, fs.innerText);
gl.compileShader(fragmentShader);
gl.attachShader(program, fragmentShader);

gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.log(gl.getShaderInfoLog(vertexShader));
    console.log(gl.getShaderInfoLog(fragmentShader));
}

gl.useProgram(program);

const uResolutionLoc = gl.getUniformLocation(program, 'u_resolution');
gl.uniform2f(uResolutionLoc, canvas.width, canvas.height);

const uTimeLoc = gl.getUniformLocation(program, 'u_time');

const uMousePosLoc = gl.getUniformLocation(program, "u_mouse_pos");

const uBall_xy_Loc = gl.getUniformLocation(program, 'u_ball.xy');
const uBall_v_Loc = gl.getUniformLocation(program, 'u_ball.v');

const uPad_width_Loc = gl.getUniformLocation(program, 'u_pad.width');
const uPad_height_Loc = gl.getUniformLocation(program, 'u_pad.height');
const uPad_rgb_Loc = gl.getUniformLocation(program, 'u_ball.rgba');

var uBall = {};
var uPad = {width: 0.5, height: 0.05};

uBall.init = function()
{
    this.r = 0.1;
    this.xy = [0.0, 0.0];
    const alpha = 17.11 * Math.random();
    this.v = [0.03 * Math.sin(alpha), 0.03 * Math.cos(alpha)];
}

uBall.init();

gl.uniform1f(gl.getUniformLocation(program, 'u_ball.r'), uBall.r);
gl.uniform2f(uBall_xy_Loc, uBall.xy[0], uBall.xy[1]);
gl.uniform2f(uBall_v_Loc, uBall.v[0], uBall.v[1]);
gl.uniform4f(gl.getUniformLocation(program, 'u_ball.rgba'), 1.0, 0.0, 0.0, 1.0);

gl.uniform1f(gl.getUniformLocation(program, 'u_pad.width'), uPad.width);
gl.uniform1f(gl.getUniformLocation(program, 'u_pad.height'), uPad.height);
gl.uniform4f(gl.getUniformLocation(program, 'u_pad.rgba'), 1.0, 1.0, 0.0, 1.0);

draw = function()
{
    gl.uniform1f(uTimeLoc, performance.now() * 0.001);
    gl.uniform2f(uMousePosLoc, normMouseX, normMouseY);
    gl.uniform2f(uBall_xy_Loc, uBall.xy[0], uBall.xy[1]);
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    const error = gl.getError();
    if(error !== gl.NO_ERROR)
        console.error("WebGL error:", error);

    const next_x = uBall.xy[0] + uBall.v[0];
    const next_y = uBall.xy[1] + uBall.v[1];
    if(next_x < -1 + uBall.r || next_x > 1 - uBall.r)
        uBall.v[0] = -uBall.v[0];
    if(next_y < -1 + uBall.r || next_y > 1 - uBall.r)
        uBall.v[1] = -uBall.v[1];

    const pad_left = normMouseX - uPad.width / 2.0;
    const pad_right = normMouseX + uPad.width / 2.0;
    const pad_top = -1.0 + uPad.height;
    if(next_x + uBall.r > pad_left
        && next_x - uBall.r < pad_right
        && next_y - uBall.r < pad_top)
    {
        uBall.v[1] = -uBall.v[1];
    }
    uBall.xy[0] = next_x;
    uBall.xy[1] = next_y;
    requestAnimationFrame(draw);
}
draw();

function resizeSquareCanvas() {
    const dpr = window.devicePixelRatio || 1;

    const cssSize = Math.min(
        window.innerWidth,
        window.innerHeight
    );

    // CSS size (layout)
    canvas.style.width  = cssSize + "px";
    canvas.style.height = cssSize + "px";

    // Actual WebGL buffer size
    canvas.width  = Math.floor(cssSize * dpr);
    canvas.height = Math.floor(cssSize * dpr);

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.uniform2f(uResolutionLoc, canvas.width, canvas.height);
}

window.addEventListener("resize", resizeSquareCanvas);
resizeSquareCanvas();

</script>
</html>
