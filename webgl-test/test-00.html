<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
}

body {
    display: flex;
    align-items: center;
    justify-content: center;
}

canvas {
    display: block;
}
</style>

<title>test-00</title>
</head>
<body>
<canvas width=400 height=400></canvas>
<script id="vs" type="x-shader/x-vertex">#version 300 es
precision highp float;

const vec2 pos[3] = vec2[](
    vec2(-1.0, -1.0),
    vec2( 3.0, -1.0),
    vec2(-1.0,  3.0)
);

void main() {
    gl_Position = vec4(pos[gl_VertexID], 0.0, 1.0);
}
</script>


<script id="fs" type="x-shader/x-fragment">#version 300 es
precision mediump float;

#define PI 3.141592653589793

struct BALL
{
    float r;
    vec2 xy;
    vec2 v;
    vec4 rgba;
};

uniform vec2 u_resolution;
uniform float u_time;
uniform vec2 u_mouse_pos;

uniform BALL u_ball;

out vec4 frag_color;

float hash12(vec2 p)
{
    vec3 p3  = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

vec4 draw_background()
{
    vec2 p = gl_FragCoord.xy;

    float n = hash12(p + floor(u_time * 10.0));
    return vec4(vec3(n), 1.0);
}

vec4 draw_ball(in BALL self, in vec4 prev_clr, in vec2 frag_xy)
{
    float d = length(self.xy - frag_xy);

    float mask = 1.0 - smoothstep(self.r - 0.01, self.r, d);

    float brightness = (frag_xy.x - self.xy.x) / self.r;
    brightness = brightness * 0.5 + 0.5;
    brightness = clamp(brightness, 0.0, 1.0);

    return mix(prev_clr, self.rgba * brightness, mask);
}

vec4 draw_border(in vec4 prev_clr, vec4 border_clr)
{
    vec2 p = gl_FragCoord.xy;
    return (p.x < 1.0
            || p.y < 1.0
            || p.x > u_resolution.x - 1.0
            || p.y > u_resolution.y - 1.0) ? border_clr : prev_clr;
}

void main()
{
    vec2 frag_xy = 2.0 * gl_FragCoord.xy / u_resolution - 1.0;
    vec4 curr_clr = draw_background();
    curr_clr = draw_ball(u_ball, curr_clr, frag_xy);
    curr_clr = draw_border(curr_clr, vec4(0.0, 1.0, 0.0, 1.0));
    frag_color = curr_clr;
}
</script>
</body>
<script>
const canvas = document.querySelector('canvas');
var normMouseX = 0.0;
var normMouseY = 0.0;
canvas.addEventListener("mousemove", (event) => {
        const rect = canvas.getBoundingClientRect();

        normMouseX = 2.0 * (event.clientX - rect.left) / canvas.width - 1.0;
        normMouseY = 2.0 * (rect.top - event.clientY) / canvas.height + 1.0;
        });

const gl = canvas.getContext('webgl2');
const program = gl.createProgram();

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, vs.innerText);
gl.compileShader(vertexShader);
gl.attachShader(program, vertexShader);

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, fs.innerText);
gl.compileShader(fragmentShader);
gl.attachShader(program, fragmentShader);

gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.log(gl.getShaderInfoLog(vertexShader));
    console.log(gl.getShaderInfoLog(fragmentShader));
}

gl.useProgram(program);

const uResolutionLoc = gl.getUniformLocation(program, 'u_resolution');
gl.uniform2f(uResolutionLoc, canvas.width, canvas.height);

const uTimeLoc = gl.getUniformLocation(program, 'u_time');

const uMousePosLoc = gl.getUniformLocation(program, "u_mouse_pos");

const uBall_xy_Loc = gl.getUniformLocation(program, 'u_ball.xy');
const uBall_v_Loc = gl.getUniformLocation(program, 'u_ball.v');

var uBall = {};

uBall.init = function()
{
    this.r = 0.1
    this.xy = [0.0, 0.0];
    const alpha = 17.11 * Math.random();
    this.v = [0.03 * Math.sin(alpha), 0.03 * Math.cos(alpha)];
}

uBall.init();

gl.uniform1f(gl.getUniformLocation(program, 'u_ball.r'), uBall.r);
gl.uniform2f(uBall_xy_Loc, uBall.xy[0], uBall.xy[1]);
gl.uniform2f(uBall_v_Loc, uBall.v[0], uBall.v[1]);
gl.uniform4f(gl.getUniformLocation(program, 'u_ball.rgba'), 1.0, 0.0, 0.0, 1.0);

draw = function()
{
    gl.uniform1f(uTimeLoc, performance.now() * 0.001);
    gl.uniform2f(uMousePosLoc, normMouseX, normMouseY);
    gl.uniform2f(uBall_xy_Loc, uBall.xy[0], uBall.xy[1]);
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    const error = gl.getError();
    if(error !== gl.NO_ERROR)
        console.error("WebGL error:", error);

    uBall.xy[0] += uBall.v[0];
    uBall.xy[1] += uBall.v[1];
    if(uBall.xy[0] < -1 + uBall.r || uBall.xy[0] > 1 - uBall.r)
        uBall.v[0] = -uBall.v[0];
    if(uBall.xy[1] < -1 + uBall.r || uBall.xy[1] > 1 - uBall.r)
        uBall.v[1] = -uBall.v[1];
    requestAnimationFrame(draw);
}
draw();

function resizeSquareCanvas() {
    const dpr = window.devicePixelRatio || 1;

    const cssSize = Math.min(
        window.innerWidth,
        window.innerHeight
    );

    // CSS size (layout)
    canvas.style.width  = cssSize + "px";
    canvas.style.height = cssSize + "px";

    // Actual WebGL buffer size
    canvas.width  = Math.floor(cssSize * dpr);
    canvas.height = Math.floor(cssSize * dpr);

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.uniform2f(uResolutionLoc, canvas.width, canvas.height);
}

window.addEventListener("resize", resizeSquareCanvas);
resizeSquareCanvas();

</script>
</html>
